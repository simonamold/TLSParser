from .enums.content_types import ContentType
from .enums.tls_version import TLSVersion
from .exceptions import *
from .utils.EnumResolver import EnumResolver
#from tls_alert import TLSAlert

# Record structure:
# - content type = 1 byte
# - version = 2 bytes
# - length = 2 bytes max 2^14
# Ex = \x16\x03\x03\x00\x31

"""
    Considerations regarding the implementation:
    - I initially wanted to make length and value validations directly in th constructure
    - I realised I cannot instantiate the object without  trawing exceptions if the packet is malformed
    - I dedided to store the byte sequence as it enters and parse it separately
    - I thought about using placeholders in case I receive a malformed packet, basically to imitate the correct structure, however that could be problematic
    - 
"""
PLACEHOLDER_VALUE = b'\xff'

class TLSRecord:
    def __init__(self, raw_bytes: bytes):
        self.raw = raw_bytes
        self.raw_content_type = PLACEHOLDER_VALUE
        self.raw_version = PLACEHOLDER_VALUE * 2
        self.length = 0
        self.fragment = b''
        self.content_type = None
        self.version = None
        self.content = None

        """ I was thinking to replace missing bytes from the header with placeholder
            I might nit be the best idea
        """

        self.raw_content_type = self.raw[0] if len(self.raw) >= 1 else PLACEHOLDER_VALUE
        self.raw_version = self.raw[1:3] if len(self.raw) >= 3 else self._get_raw_version(self.raw)
        
        
        if len(self.raw) >= 5:
            self.length = int.from_bytes(self.raw[3:5], byteorder='big')
        else:
            self.length = 0
        if len(self.raw) >= 5 + self.length:
            self.fragment = self.raw[5:5 + self.length]
        elif len(self.raw) > 5:
            self.fragment = self.raw[5:]
        else:
            self.fragment = b''

    def parse(self):
        if self.length < 5:
            raise IncompleteHeaderError("TLS record header is incomplete")
        if self.raw_content_type is None or self.raw_version is None or self.length is None:
            raise IncompleteHeaderError("TLS record header is incomplete")
        if self.fragment is None:
            raise IncompletePayloadError("TLS record payload is incomplete")
        
        self.content_type = EnumResolver.parse(
            ContentType, self.raw_content_type,
            exception_cls=UnknownTLSContentTypeError
        )

        self.version = EnumResolver.parse(
            TLSVersion, self.raw_version,
            exception_cls=UnknownTLSVersionError
        )

        # try:
        #     if self.content_type == ContentType.HANDSHAKE:
        #         self.content = TLSHandshake.parse(self.fragment)
            
        # except Exception:
        #     self.content = None  # Keep the record even on parser failure

        return self

    @staticmethod
    def _get_raw_version(raw_bytes: bytes) -> bytes:
        version_bytes = raw_bytes[1:3]
        if len(version_bytes) < 2 :
            return version_bytes + PLACEHOLDER_VALUE * (2 - len(version_bytes))
        return version_bytes  
    
    def __str__(self):
        return (
            f"Content Type: {self.content_type.name if self.content_type else self.raw_content_type}\n"
            f"Version: {self.version.name if self.version else self.raw_version.hex()}\n"
            f"Length: {self.length}\n"
            f"Fragment: {self.fragment.hex()[:60]}...\n"
            f"Parsed Content: {self.content if self.content else 'None'}"
        )